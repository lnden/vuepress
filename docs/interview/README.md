# 前端优化

## 当输入一个URL浏览器怎么执行的
1.DNS域名解析   浏览器自身DNS，操作系统DNS，读取HOST文件，向域名发起请求

2.建立TCP连接   三次握手

3.发起HTTP请求   请求报文，cookie，主体，响应头

4.接受响应结果   setcookie，返回HTTP状态吗200

5.浏览器解析HTML   构建DOM树，下载资源，构建渲染

6.浏览器布局渲染   布局，绘制

## 浏览器的组成部分

- 用户界面：
包括地址栏、后退/前进按钮、书签目录

- 浏览器引擎：
用来查询及操作渲染引擎的接口

- 渲染引擎：
用来显示请求的内容，请求内容为html，它负责解析html及css，解析后展示结果

- 网络：
用来完成网络调用，HTTP请求，具有平台无关的接口，可以在不同平台工作

- UI后端：
用来绘制类似组合选择框及对话框等基本组件

- JS解释器：
用来解析执行JS代码

- 数据存储：
属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据

<img :src="$withBase('/browser.png')" alt="browser" width="400">


## 渲染引擎的基本流程

- Chrome的Webkit主流程
<img :src="$withBase('/webkit.png')" alt="webkit" width="600">

```
元素结构 → 元素解析器 → DOM树

                           →   附着合成     →    渲染树(Layout)    →   显示

样式表 → 样式解析器 → 样式规则树
```

- Mozilla的Geoko主流程
<img :src="$withBase('/mozilla.jpg')" alt="mozilla" width="600">

## 重绘和回流的区别

- replaint：(重绘)屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。
- reflow：(回流)又叫重排（layout）意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。

- <b>重点：</b>回流必定会触发重绘，重绘不一定会触发回流。重绘的开销较小，回流的代价较高。

- <b>那么，在工作中我们要如何避免大量使用重绘与回流呢？</b>

1.避免频繁操作样式，可汇总后统一一次修改

2.尽量使用 class 进行样式修改，而不是直接操作样式

3.减少 DOM 的操作，可使用字符串一次性插入

## 什么是http协议

- 什么是http协议
&emsp;&emsp;http协议其实就是超文本传输协议，超文本传输协议是一种详细规定了浏览器和外围网服务器之间的规则。

通过因特网传送万维网文档的数据传送协议，在整个ios传输层次模型中http处于最高层次，而tcp是处于下面一层传输，也就是说 http是基于tap协议建立的链接，所以http传输建立之前需要建立tcp链接，也就是三次握手，在建立tcp链接之后方可真正请求响应请求。

- http传输过程详解
当我们发送以一个ajax请求，或者地址栏输入url后，我们的浏览器就给web服务器发送一个request，之后服务器处理完成后返回响应的response给浏览器。之后浏览器拿到数据进行解析里面数据从而生成我们页面或者组建数据。

期间传送还有可能经历了代理服务器（目前很多很多网站都用代理服务器，主要原因是其隐蔽）从而实现服务端文件缓存

http传输是面向链接的，也就是说如果链接没有终端，可以继续发送请求，整个设置可以在请求头connection来设置，例如：我通过一个URL请求来一个html页面后。

经分析，html页面中包含对图片的请求没，则会直接在向服务器发起请求而不必重新建立tcp链接，等到所有请求都就绪，方可完成一次页面加载或者请求完毕。


## http和https的区别
- https协议需要CA申请证书，一般免费证书比较少，所以需要一定费用。
- http是超文本传输协议，信息是明文传输，https则是具有安全性的SSL加密传输协议
- http和https 使用的是完全不同的连接方式，使用的端口号也不一样，前端是80，后者443
- http连接很简单，是无状态的，服务端无法区分请求，所以cookie登场，https协议是由http+SSL洗衣构建可以进行加密传输，身份认真的网络协议，比较安全
- 另外谷歌所受引擎算法中，比起同等http网站，采用https加密的网站在搜索结果排名中会更高

## TCP三次握手

主要是为了防止客户端发出的已失效的连接请求报文突然又传到了服务器，因而产生错误。

正常情况：

A发出了连接请求，但连接请求报文丢失而未受到确认，于是A再重新传一次连接请求，后来受到了确认，建立了连接，数据传输完毕后，就释放了连接，A共发送了两个连接请求报文段，其中第一个丢失，第二个达到了B

异常情况:

即A发出的第一个连接请求报文字段并没有丢失，而是在某个网络节点长时间滞留，以至延误到连接释放以后的某个时间才到达B，本来这是一个早已失效的报文字段，但B收到此失效的 连接请求报文字段后，会误以为是A又发出一次新的连接请求，于是就像A发出确认报文段，同意建立连接，假定不采用第三次握手，那么只要B发出确认，新的连接就建立了，一直等待A发送数据过来，使得B许多资源就浪费了，所以采用三次握手的方法可以防止上述现象发生，在刚才的情况下，A不会向B发出第二次确认，B由于收不到确认，就知道A并没有要求建立连接。


## 前端性能优化

1.减少http的请求次数

2.减少DNS的查询次数

3.尽量少用iframe

4.减少DOM的操作

5.使用CDN网络分发

6.ajax缓存机制

7.css放在头部HTML规范清楚指出样式表要放包含在页面的`<head />`区域内；

8.把JS放到底部HTTP/1.1 规范建议，浏览器每个主机名的并行下载内容不超过两个，而问题在于脚本阻止了页面的平行下载，即便是主机名不相同

9.将CSS和JS放到外部文件中

10.用`<link>`代替@import

11.优化CSS Spirite

12.小图片使用base64

13.图片使用懒加载

14.合并打包压缩

15.将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载

16.减少iframe数量

## 渐进增强、优雅降级

开始针对低版本浏览器进行构建，完成基本的功能，然后针对高版本浏览器进行效果、交互得到更好的体验

开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。


## 浏览器内核都有哪些

 - IE trident内核
 - Firefox gecko内核
 - Safari webkit内核
 - Opera  以前是presto内核  现已用chrome的Blink 内核
 - Chrome Blink 基于webkit